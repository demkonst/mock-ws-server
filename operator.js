const fs = require('fs');
const WebSocket = require('ws');
const dotenv = require('dotenv');
const { interpolateCoordinates, calculateDistance } = require('./vehicle.js');

function loadEnvFor(env) {
  dotenv.config({ path: `.env.${env}` });
}

async function getOperatorToken(operatorId, env = 'dev') {
  loadEnvFor(env);
  const baseUrl = process.env.BASE_URL_UNITS;
  const authHeader = process.env.AUTH_HEADER || 'Basic aW5rLW1vbjppbmttb25pdG9yaW5n';
  
  if (!baseUrl) {
    throw new Error('–ù–µ –Ω–∞–π–¥–µ–Ω BASE_URL_UNITS');
  }

  // –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –∏–º—è –æ–ø–µ—Ä–∞—Ç–æ—Ä–∞ –≤ —á–∏—Å–ª–æ–≤–æ–π ID —á–µ—Ä–µ–∑ –º–∞–ø–ø–∏–Ω–≥
  const numericOperatorId = operatorId;
  console.log(`üîÑ [${operatorId}] ID –æ–ø–µ—Ä–∞—Ç–æ—Ä–∞ –¥–ª—è API: ${numericOperatorId}`);
  console.log(`üîó [${operatorId}] URL: ${baseUrl.replace(/\/$/, '')}/operators/credentials?operator_id=${numericOperatorId}`);
  console.log(`üîê [${operatorId}] Auth header: ${authHeader}`);

  try {
    // –ü–æ–ª—É—á–∞–µ–º credentials –¥–ª—è –æ–ø–µ—Ä–∞—Ç–æ—Ä–∞
    const credentialsUrl = `${baseUrl.replace(/\/$/, '')}/operators/credentials?operator_id=${numericOperatorId}`;
    const credentialsResponse = await fetch(credentialsUrl, {
      headers: {
        'Accept': 'application/json',
        'Authorization': authHeader
      }
    });

    console.log(`üì° [${operatorId}] Response status: ${credentialsResponse.status}`);
    console.log(`üì° [${operatorId}] Response headers:`, Object.fromEntries(credentialsResponse.headers.entries()));

    if (!credentialsResponse.ok) {
      const errorText = await credentialsResponse.text();
      console.error(`‚ùå [${operatorId}] Error response: ${errorText}`);
      throw new Error(`–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è credentials: ${credentialsResponse.status}`);
    }

    const credentials = await credentialsResponse.json();
    console.log(`üìã [${operatorId}] –ü–æ–ª—É—á–µ–Ω—ã credentials`);

    // –õ–æ–≥–∏–Ω–∏–º—Å—è —Å –ø–æ–ª—É—á–µ–Ω–Ω—ã–º–∏ credentials
    const loginUrl = `${baseUrl.replace(/\/$/, '')}/auth/operator/login`;
    const loginResponse = await fetch(loginUrl, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
        'Authorization': authHeader
      },
      body: JSON.stringify({
        login: credentials.login,
        password: credentials.password
      })
    });

    console.log(`üîê [${operatorId}] Login response status: ${loginResponse.status}`);

    if (!loginResponse.ok) {
      const errorText = await loginResponse.text();
      console.error(`‚ùå [${operatorId}] Login error response: ${errorText}`);
      throw new Error(`–û—à–∏–±–∫–∞ –ª–æ–≥–∏–Ω–∞: ${loginResponse.status}`);
    }

    const loginData = await loginResponse.json();
    console.log(`üîë [${operatorId}] –ü–æ–ª—É—á–µ–Ω —Ç–æ–∫–µ–Ω: ${loginData.token || loginData.access_token}`);
    
    return loginData.token || loginData.access_token;
  } catch (error) {
    console.error(`‚ùå [${operatorId}] –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Ç–æ–∫–µ–Ω–∞:`, error.message);
    throw error;
  }
}

function connectOperator(operator, env = 'dev', operatorId = null) {
  loadEnvFor(env);
  if (!operator) {
    console.error('‚ùå –ù–µ —É–∫–∞–∑–∞–Ω –æ–ø–µ—Ä–∞—Ç–æ—Ä!');
    return Promise.reject(new Error('–ù–µ —É–∫–∞–∑–∞–Ω –æ–ø–µ—Ä–∞—Ç–æ—Ä'));
  }

  const baseUrl = process.env.BASE_URL_COLLECTOR;
  if (!baseUrl) {
    console.error('‚ùå BASE_URL_COLLECTOR –Ω–µ –æ–ø—Ä–µ–¥–µ–ª—ë–Ω –≤ .env');
    return Promise.reject(new Error('–ù–µ –Ω–∞–π–¥–µ–Ω BASE_URL_COLLECTOR'));
  }
  const wsUrl = `${baseUrl.replace(/\/$/, '')}/locations/ws`;
  console.log(`üîó [${operator}] WebSocket URL: ${wsUrl}`);
  
  return new Promise(async (resolve, reject) => {
    try {
      let TOKEN;
      
      // –í—Å–µ–≥–¥–∞ –∏—Å–ø–æ–ª—å–∑—É–µ–º API –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è —Ç–æ–∫–µ–Ω–∞
      // –ï—Å–ª–∏ operatorId –ø–µ—Ä–µ–¥–∞–Ω, –∏—Å–ø–æ–ª—å–∑—É–µ–º –µ–≥–æ, –∏–Ω–∞—á–µ –∏—Å–ø–æ–ª—å–∑—É–µ–º –∏–º—è –æ–ø–µ—Ä–∞—Ç–æ—Ä–∞
      console.log(`üîç [${operator}] operatorId: "${operatorId}", operator: "${operator}"`);
      const targetOperatorId = (operatorId && operatorId !== 'null') ? operatorId : operator;
      console.log(`üîç [${operator}] targetOperatorId: "${targetOperatorId}"`);
      TOKEN = await getOperatorToken(targetOperatorId, env);
      console.log(`üîê [${operator}] –ò—Å–ø–æ–ª—å–∑—É–µ–º —Ç–æ–∫–µ–Ω: ${TOKEN.substring(0, 20)}...`);

      const ws = new WebSocket(wsUrl, {
        headers: {
          Authorization: `Bearer ${TOKEN}`
        }
      });
      
      ws.once('open', () => {
        console.log(`‚úÖ [${operator}] –ü–æ–¥–∫–ª—é—á–µ–Ω–æ`);
        resolve({ ws });
      });
      
      ws.once('error', err => {
        console.error(`‚ö†Ô∏è [${operator}] –û—à–∏–±–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è: ${err.message}`);
        reject(err);
      });
    } catch (error) {
      reject(error);
    }
  });
}

function getCloseReason(code, reason) {
  const reasons = {
    1000: 'Normal Closure',
    1001: 'Going Away',
    1002: 'Protocol Error',
    1003: 'Unsupported Data',
    1005: 'No Status Received',
    1006: 'Abnormal Closure',
    1007: 'Invalid frame payload data',
    1008: 'Policy Violation',
    1009: 'Message too big',
    1010: 'Mandatory Extension',
    1011: 'Internal Server Error',
    1015: 'TLS Handshake'
  };
  const reasonText = reasons[code] || 'Unknown';
  return `${reasonText} (${code})${reason ? ` - ${reason}` : ''}`;
}

function generateMessagesFromWaypoints(waypoints, config) {
  const { speed = 40, course = 90, altitude = 10, delay = 2000, interpolate = true } = config;
  
  // –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –∏–∑ [lon, lat] –∏–ª–∏ [lat, lon] –≤ {lat, lon}
  const convertedWaypoints = waypoints.map(coord => {
    if (Array.isArray(coord) && coord.length === 2) {
      // –û–ø—Ä–µ–¥–µ–ª—è–µ–º, –∫–∞–∫–æ–π —Ñ–æ—Ä–º–∞—Ç –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è: [lon, lat] –∏–ª–∏ [lat, lon]
      const first = coord[0];
      const second = coord[1];
      
      // –ï—Å–ª–∏ –ø–µ—Ä–≤–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ > 90, —Ç–æ —ç—Ç–æ –¥–æ–ª–≥–æ—Ç–∞ (lon), –∏–Ω–∞—á–µ —à–∏—Ä–æ—Ç–∞ (lat)
      if (Math.abs(first) > 90) {
        // –§–æ—Ä–º–∞—Ç [lon, lat] - –Ω—É–∂–Ω–æ –ø–æ–º–µ–Ω—è—Ç—å –º–µ—Å—Ç–∞–º–∏
        return { lon: first, lat: second };
      } else {
        // –§–æ—Ä–º–∞—Ç [lat, lon] - —É–∂–µ –≤ –ø—Ä–∞–≤–∏–ª—å–Ω–æ–º –ø–æ—Ä—è–¥–∫–µ
        return { lat: first, lon: second };
      }
    } else if (coord.lat && coord.lon) {
      return coord; // —É–∂–µ –≤ –ø—Ä–∞–≤–∏–ª—å–Ω–æ–º —Ñ–æ—Ä–º–∞—Ç–µ
    } else {
      throw new Error(`–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã: ${JSON.stringify(coord)}. –û–∂–∏–¥–∞–µ—Ç—Å—è [lon, lat], [lat, lon] –∏–ª–∏ {lat, lon}`);
    }
  });
  
  let finalCoords;
  
  if (interpolate) {
    // –ò–Ω—Ç–µ—Ä–ø–æ–ª–∏—Ä—É–µ–º –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –Ω–∞ –æ—Å–Ω–æ–≤–µ —Å–∫–æ—Ä–æ—Å—Ç–∏
    const speedMps = speed / 3.6; // –∫–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º –∫–º/—á –≤ –º/—Å
    const intervalMs = delay; // –∏—Å–ø–æ–ª—å–∑—É–µ–º delay –∫–∞–∫ –∏–Ω—Ç–µ—Ä–≤–∞–ª
    finalCoords = interpolateCoordinates(convertedWaypoints, speedMps, intervalMs);
    console.log(`üîÑ [Operator] –ò–Ω—Ç–µ—Ä–ø–æ–ª—è—Ü–∏—è: ${convertedWaypoints.length} waypoints ‚Üí ${finalCoords.length} —Ç–æ—á–µ–∫`);
  } else {
    // –ò—Å–ø–æ–ª—å–∑—É–µ–º waypoints –∫–∞–∫ –µ—Å—Ç—å, –±–µ–∑ –∏–Ω—Ç–µ—Ä–ø–æ–ª—è—Ü–∏–∏
    finalCoords = convertedWaypoints;
    console.log(`üìç [Operator] –ë–µ–∑ –∏–Ω—Ç–µ—Ä–ø–æ–ª—è—Ü–∏–∏: ${finalCoords.length} waypoints`);
  }
  
  // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º —Å–æ–æ–±—â–µ–Ω–∏—è –¥–ª—è –∫–∞–∂–¥–æ–π —Ç–æ—á–∫–∏
  const messages = finalCoords.map((coord, index) => {
    return {
      payload: {
        lat: coord.lat,
        lon: coord.lon,
        timestamp: Math.floor(Date.now() / 1000) + index * 2,
        speed: speed,
        speed_accuracy: 1,
        course: course,
        course_accuracy: 5,
        altitude: altitude,
        altitude_accuracy: 2
      },
      delay: delay
    };
  });
  
  return messages;
}

function runOperator(operator, env = 'dev', ws = null, timeout = null, customCoords = null, operatorId = null) {
  loadEnvFor(env);
  console.log(`üîç [${operator}] runOperator –≤—ã–∑–≤–∞–Ω —Å operatorId: "${operatorId}"`);
  let messages;
  
  try {
          if (customCoords) {
        // –ò—Å–ø–æ–ª—å–∑—É–µ–º –∫–∞—Å—Ç–æ–º–Ω—ã–µ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –∏–∑ –∑–∞–ø—Ä–æ—Å–∞
        console.log(`üöÄ [${operator}] –ò—Å–ø–æ–ª—å–∑—É–µ–º –∫–∞—Å—Ç–æ–º–Ω—ã–µ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã: ${customCoords.length} —Ç–æ—á–µ–∫`);
        
        if (Array.isArray(customCoords)) {
          // –ü—Ä–æ—Å—Ç–æ–π –º–∞—Å—Å–∏–≤ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç [lon, lat]
          messages = generateMessagesFromWaypoints(customCoords, {
            speed: 40,
            course: 90,
            altitude: 10,
            delay: 2000,
            interpolate: true
          });
        } else if (customCoords.coords && customCoords.operator_id) {
          // –û–±—ä–µ–∫—Ç —Å –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞–º–∏ –∏ operator_id
          const config = {
            speed: customCoords.speed || 40,
            course: customCoords.course || 90,
            altitude: customCoords.altitude || 10,
            delay: customCoords.delay || 2000,
            interpolate: customCoords.interpolate !== false
          };
          
          console.log(`‚ö° [${operator}] –ö–∞—Å—Ç–æ–º–Ω—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã: —Å–∫–æ—Ä–æ—Å—Ç—å=${config.speed} –∫–º/—á, –∫—É—Ä—Å=${config.course}¬∞, –≤—ã—Å–æ—Ç–∞=${config.altitude}–º, –∑–∞–¥–µ—Ä–∂–∫–∞=${config.delay}–º—Å, –∏–Ω—Ç–µ—Ä–ø–æ–ª—è—Ü–∏—è=${config.interpolate}`);
          
          messages = generateMessagesFromWaypoints(customCoords.coords, config);
          operatorId = customCoords.operator_id;
        } else {
          throw new Error(`–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –∫–∞—Å—Ç–æ–º–Ω—ã—Ö –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç –¥–ª—è ${operator}`);
        }
    } else {
      // –ò—Å–ø–æ–ª—å–∑—É–µ–º –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –∏–∑ —Ñ–∞–π–ª–∞
      const operatorNum = operator.toString().padStart(2, '0');
      const filePath = `operators_${env}/operator_${operatorNum}.json`;
      const fileContent = fs.readFileSync(filePath);
      const data = JSON.parse(fileContent);
      
      // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ —ç—Ç–æ –Ω–æ–≤—ã–º —Ñ–æ—Ä–º–∞—Ç–æ–º —Å waypoints
      if (data.waypoints && Array.isArray(data.waypoints)) {
        // –ù–æ–≤—ã–π —Ñ–æ—Ä–º–∞—Ç: –≥–µ–Ω–µ—Ä–∏—Ä—É–µ–º —Å–æ–æ–±—â–µ–Ω–∏—è –∏–∑ waypoints
        console.log(`üöÄ [${operator}] –ò—Å–ø–æ–ª—å–∑—É–µ–º –Ω–æ–≤—ã–π —Ñ–æ—Ä–º–∞—Ç —Å waypoints: ${data.waypoints.length} —Ç–æ—á–µ–∫`);
        messages = generateMessagesFromWaypoints(data.waypoints, data);
      } else if (Array.isArray(data)) {
        // –°—Ç–∞—Ä—ã–π —Ñ–æ—Ä–º–∞—Ç: –º–∞—Å—Å–∏–≤ —Å–æ–æ–±—â–µ–Ω–∏–π
        console.log(`üöÄ [${operator}] –ò—Å–ø–æ–ª—å–∑—É–µ–º —Å—Ç–∞—Ä—ã–π —Ñ–æ—Ä–º–∞—Ç: ${data.length} —Å–æ–æ–±—â–µ–Ω–∏–π`);
        messages = data;
      } else {
        throw new Error(`–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç —Ñ–∞–π–ª–∞ –æ–ø–µ—Ä–∞—Ç–æ—Ä–∞: ${filePath}`);
      }
      
      // –î–ª—è —Ñ–∞–π–ª–æ–≤—ã—Ö –æ–ø–µ—Ä–∞—Ç–æ—Ä–æ–≤ –∏—Å–ø–æ–ª—å–∑—É–µ–º ID –∏–∑ –∏–º–µ–Ω–∏ —Ñ–∞–π–ª–∞ (—Å –æ–±—Ä–µ–∑–∫–æ–π –≤–µ–¥—É—â–∏—Ö –Ω—É–ª–µ–π)
      if (!operatorId || operatorId === 'null') {
        // –£–±–∏—Ä–∞–µ–º –≤–µ–¥—É—â–∏–µ –Ω—É–ª–∏ –∏–∑ –∏–º–µ–Ω–∏ –æ–ø–µ—Ä–∞—Ç–æ—Ä–∞ –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è —á–∏—Å–ª–æ–≤–æ–≥–æ ID
        console.log(`üîç [${operator}] –ò—Å—Ö–æ–¥–Ω–æ–µ –∏–º—è –æ–ø–µ—Ä–∞—Ç–æ—Ä–∞: "${operator}"`);
        const withoutLeadingZeros = operator.replace(/^0+/, '');
        console.log(`üîç [${operator}] –ü–æ—Å–ª–µ —É–¥–∞–ª–µ–Ω–∏—è –≤–µ–¥—É—â–∏—Ö –Ω—É–ª–µ–π: "${withoutLeadingZeros}"`);
        operatorId = withoutLeadingZeros || operator;
        console.log(`üÜî [${operator}] ID –æ–ø–µ—Ä–∞—Ç–æ—Ä–∞ –∏–∑ –∏–º–µ–Ω–∏ —Ñ–∞–π–ª–∞: ${operatorId}`);
      }
    }
  } catch (err) {
    console.error(`‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –ø—Ä–æ—á–∏—Ç–∞—Ç—å operators_${env}/operator_${operator.toString().padStart(2, '0')}.json: ${err.message}`);
    return Promise.reject(err);
  }

  const getWs = ws
    ? Promise.resolve({ ws })
    : connectOperator(operator, env, operatorId);

  return getWs.then(({ ws }) => {
    return new Promise((resolve, reject) => {
      let output = '';
      let totalDelay = 0;
      let timeoutId = null;
      let isRunning = true;
      let activeTimers = []; // –ú–∞—Å—Å–∏–≤ –¥–ª—è –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è –∞–∫—Ç–∏–≤–Ω—ã—Ö —Ç–∞–π–º–µ—Ä–æ–≤

      // –£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å —Ç–∞–π–º–∞—É—Ç, –µ—Å–ª–∏ –ø–µ—Ä–µ–¥–∞–Ω
      if (timeout) {
        timeoutId = setTimeout(() => {
          isRunning = false;
          console.log(`‚è∞ [${operator}] –î–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å –∏—Å—Ç–µ–∫–ª–∞ (${timeout}—Å), –∑–∞–≤–µ—Ä—à–∞–µ–º –æ—Ç–ø—Ä–∞–≤–∫—É`);
          // –û—á–∏—Å—Ç–∏—Ç—å –≤—Å–µ –∞–∫—Ç–∏–≤–Ω—ã–µ —Ç–∞–π–º–µ—Ä—ã
          activeTimers.forEach( timerId => clearTimeout( timerId ) );
          activeTimers = [];
          resolve(output);
        }, timeout * 1000);
      }

      ws.on('message', data => {
        console.log(`‚¨ÖÔ∏è [${operator}] ${data}`);
        output += `‚¨ÖÔ∏è [${operator}] ${data}\n`;
      });

      ws.on('close', (code, reason) => {
        isRunning = false;
        if ( timeoutId ) {
          clearTimeout( timeoutId );
          timeoutId = null;
        }
        // –û—á–∏—Å—Ç–∏—Ç—å –≤—Å–µ –∞–∫—Ç–∏–≤–Ω—ã–µ —Ç–∞–π–º–µ—Ä—ã
        activeTimers.forEach( timerId => clearTimeout( timerId ) );
        activeTimers = [];
        const closeReason = getCloseReason(code, reason);
        console.log(`‚ùå [${operator}] –ó–∞–∫—Ä—ã—Ç–æ: ${closeReason}`);
        output += `‚ùå [${operator}] –ó–∞–∫—Ä—ã—Ç–æ: ${closeReason}\n`;
        resolve(output);
      });

      ws.on('error', err => {
        isRunning = false;
        if ( timeoutId ) {
          clearTimeout( timeoutId );
          timeoutId = null;
        }
        // –û—á–∏—Å—Ç–∏—Ç—å –≤—Å–µ –∞–∫—Ç–∏–≤–Ω—ã–µ —Ç–∞–π–º–µ—Ä—ã
        activeTimers.forEach( timerId => clearTimeout( timerId ) );
        activeTimers = [];
        console.error(`‚ö†Ô∏è [${operator}] –û—à–∏–±–∫–∞: ${err.message}`);
        output += `‚ö†Ô∏è [${operator}] –û—à–∏–±–∫–∞: ${err.message}\n`;
        reject(err);
      });

      // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏–π
      function sendMessages() {
        if (!isRunning) return;
        
        let cycleDelay = 0;
        messages.forEach((msg, index) => {
          cycleDelay += msg.delay;
          const timerId = setTimeout( () => {
            if (!isRunning) return;
            
            const updatedMsg = {
              ...msg,
              payload: {
                ...msg.payload,
                timestamp: Math.floor(Date.now() / 1000)
              }
            };
            const json = JSON.stringify(updatedMsg);
            console.log(`‚û°Ô∏è [${operator}] ${json}`);
            output += `‚û°Ô∏è [${operator}] ${json}\n`;

            try {
              ws.send( json );
            } catch ( err ) {
              console.error( `‚ö†Ô∏è [${operator}] –û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏: ${err.message}` );
              isRunning = false;
              return;
            }
            
            // –ï—Å–ª–∏ —ç—Ç–æ –ø–æ—Å–ª–µ–¥–Ω–µ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –≤ —Ü–∏–∫–ª–µ, –∑–∞–ø—É—Å—Ç–∏—Ç—å —Å–ª–µ–¥—É—é—â–∏–π —Ü–∏–∫–ª
            if (index === messages.length - 1) {
              const cycleTimerId = setTimeout( () => {
                if (isRunning) {
                  sendMessages(); // –†–µ–∫—É—Ä—Å–∏–≤–Ω–æ –∑–∞–ø—É—Å—Ç–∏—Ç—å —Å–ª–µ–¥—É—é—â–∏–π —Ü–∏–∫–ª
                }
              }, 1000); // –ü–∞—É–∑–∞ 1 —Å–µ–∫—É–Ω–¥–∞ –º–µ–∂–¥—É —Ü–∏–∫–ª–∞–º–∏
              activeTimers.push( cycleTimerId );
            }
          }, cycleDelay);
          activeTimers.push( timerId );
        });
      }

      // –ó–∞–ø—É—Å—Ç–∏—Ç—å –æ—Ç–ø—Ä–∞–≤–∫—É —Å–æ–æ–±—â–µ–Ω–∏–π
      sendMessages();
    });
  });
}

if (require.main === module) {
  const operator = process.argv[2] || process.env.REGION;
  const env = process.env.ENV || 'dev';
  runOperator(operator, env).catch(err => process.exit(1));
}

module.exports = { runOperator, connectOperator };
